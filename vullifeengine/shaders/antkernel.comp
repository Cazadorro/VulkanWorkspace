#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup: enable
//#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable


#include "basicreftypes.glsl"
#include "bitmask.glsl"
#include "algorithm.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;


layout(push_constant) uniform PushConstantBlock{
    uint8_array u_ant_grid;
    u32vec2_array u_ant_pos;
    uint8_array u_ant_dir;
    uint u_ant_grid_dim;
    uint u_ant_count;
};

ivec2 directions[4] = ivec2[4](ivec2(0u, 1), ivec2(1, 0), ivec2(0, -1),ivec2 (-1, 0));
void main() {
    uint tid = gl_GlobalInvocationID.x;
    if(tid < u_ant_count){
        uvec2 pos = u_ant_pos.data[tid];
        uint dir_index = uint(u_ant_dir.data[tid]);
        uint8_t grid_flag_value = u_ant_grid.data[pos.y * u_ant_grid_dim + pos.x];
        if(grid_flag_value == uint8_t(1u)){
            dir_index = (dir_index + 1u) % 4u;
        }else{
            dir_index = (4u + dir_index - 1u) % 4u;
        }
        u_ant_grid.data[pos.y * u_ant_grid_dim + pos.x] = uint8_t(1u) - grid_flag_value;
        pos = uvec2(ivec2(pos) + directions[dir_index]) % u_ant_grid_dim;
        u_ant_pos.data[tid] = pos;
        u_ant_dir.data[tid] = uint8_t(dir_index);
    }
}