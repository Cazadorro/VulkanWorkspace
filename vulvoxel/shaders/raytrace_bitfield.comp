#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup: enable
//#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable

//#include "mathutils.glsl"
//#include "basicreftypes.glsl"
//#include "bitmask.glsl"
//#include "bounds.glsl"
#include "raytracingutils.glsl"
#include "mathconstants.glsl"
#include "chunk_render_utils.glsl"
#include "basicreftypes.glsl"
#include "bitmask.glsl"
#include "algorithm.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;


struct DeviceCamera{

};

layout(set = 0, binding = 0) uniform UniformBufferObject {
    uvec2 u_resolution;
    float u_fov;
};

layout(push_constant, scalar) uniform PushConstantBlock{
    vec3 u_camera_origin;
    uint u_frame_idx;
    vec3 u_camera_rotation;
    float u_time;
};



void main(){
    uvec2 pixel_idx = gl_GlobalInvocationID.xy;

    if(pixel_idx.x >= ubo.resolution.x || pixel_idx.y >= ubo.resolution.y){
        return;
    }

    float focus_dist = u_view_state.focus_dist;//max(u_focus_dist + cos(2.0 * (float(u_frame_idx % 1000) / 1000.0) - 1.0) * 10.0, 0.1);
    float aperture = u_view_state.aperture;
    float fov = u_view_state.fov;
    float lens_radius = aperture / 2.0;
    uint tidx = gl_GlobalInvocationID.x;
    uvec2 frag_coord = pixel_from_linear(tidx);
    ivec2 pos = ivec2(frag_coord);
    ivec2 dims = ivec2(u_view_state.image_width, u_view_state.image_height);

    uvec2 resolution = uvec2(u_view_state.image_width, u_view_state.image_height);
    if (!pixel_within_image(frag_coord)){
        return;
    }


n
    vec3 total_color = vec3(0.0);

    vec3 camera_up = rotate_dir(vec3(0.0,1.0,0.0), camera_rotation);
    vec3 camera_side =  rotate_dir(vec3(1.0,0.0,0.0), camera_rotation);
    vec3 camera_forward = rotate_dir(vec3(0.0,0.0,1.0), camera_rotation);

    vec3 dir = 



}

uint get_jfa_value_at(ivec3 idx){
    return (u_voxel_jfa_in.data[to_voxel_idx(wrap(idx, int(chunk_width)))]);
}

void main() {
    uvec3 tid = gl_GlobalInvocationID;
    if(!inside_chunk(tid)){
        return;
    }
    uint linear_tid = to_voxel_idx(tid);
    uint seed_idx = get_jfa_value_at(ivec3(tid));
    if(seed_idx == linear_tid){
        if((u_jump_step_type == JUMP_STEP_END) && (u_jump_step_size == JUMP_STEP_SIZE_LAST)){
            u_voxel_sdf_out.data[linear_tid] = uint8_t(0);
        }else{
            u_voxel_jfa_out.data[linear_tid] = uint16_t(seed_idx);
        }
        return;
    }
    ivec3 offset_p = ivec3(tid);
    ivec3 offset_n = ivec3(tid);
    offset_p[u_jump_step_type] += int(u_jump_step_size);
    offset_n[u_jump_step_type] -= int(u_jump_step_size);

    uint seed_idx_p = get_jfa_value_at(offset_p);
    uint seed_idx_n = get_jfa_value_at(offset_n);

    ivec3 seed = ivec3(to_voxel_xyz(seed_idx));
    ivec3 seed_p = ivec3(to_voxel_xyz(seed_idx_p));
    ivec3 seed_n = ivec3(to_voxel_xyz(seed_idx_n));

    ivec3[3] seed_list = ivec3[3](seed_n, seed, seed_p);
    uint[3] seed_idx_list = uint[3](seed_idx_n, seed_idx, seed_idx_p);

    ivec3 location = ivec3(tid);

    uint min_dist = 0xFFFFFFFF;
    uint min_idx = seed_idx;
    for(int i = 0; i < 3; ++i){
        if(seed_idx_list[i] < 0xFFFF){
            uint dist = uint(max_v(abs(seed_list[i] - location)));
            //            uint dist = uint(abs(seed_list[i][u_jump_step_type] - location[u_jump_step_type]));
            if(min_dist > dist){
                min_dist = dist;
                min_idx = seed_idx_list[i];
            }
        }
    }

    if((u_jump_step_type == JUMP_STEP_END) && (u_jump_step_size == JUMP_STEP_SIZE_LAST)){
        if(min_dist == 0xFFFFFFFF){
            u_voxel_sdf_out.data[linear_tid] = uint8_t(0);
        }else{
            u_voxel_sdf_out.data[linear_tid] = uint8_t(min_dist);
        }
    }else{
        u_voxel_jfa_out.data[linear_tid] = uint16_t(min_idx);
    }
}
