#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup: enable
//#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable
#extension GL_EXT_nonuniform_qualifier : enable

//#include "mathutils.glsl"
//#include "basicreftypes.glsl"
//#include "bitmask.glsl"
//#include "bounds.glsl"
#include "raytracingutils.glsl"
#include "mathconstants.glsl"
#include "chunk_render_utils.glsl"
#include "basicreftypes.glsl"
#include "bitmask.glsl"
#include "algorithm.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout (constant_id = 0) const int IMAGE_COUNT = 3;
layout(set = 0, binding = 0) uniform UniformBufferObject {
    uvec2 u_resolution;
    float u_fov;
    float u_focus_distance;
};

layout(set = 0, binding = 1, r32f) uniform writeonly image2D u_output_image[];

layout(push_constant, scalar) uniform PushConstantBlock{
    vec3 u_camera_origin;
    uint u_frame_idx;
    vec3 u_camera_rotation;
    float u_time;
//32 bytes, max 128 bytes.
    uint32_array u_bitmask;
    uint64_t padding;
};

struct DebugColor{
    bool is_set;
    vec4 color;
};

bool get_bitmask(uint32_array bitmask, ivec3 cell_xyz){
    return get(bitmask, to_voxel_idx(cell_xyz));
}

bool get_bitmask(uint32_array bitmask, uint cell_index){
    return get(bitmask, cell_index);
}


////https://www.shadertoy.com/view/4dX3zl
//bool bitmask_intersect_dda(
//        uint32_array bitmask,
//        vec3 orig,
//        vec3 dir,
//        vec3 block_offset,
//        out uint voxel_index,
//        out vec3 final_crossing_T,
//        out vec3 hit_normal,
//        out vec2 texcoord,
//        out float out_t,
//        out DebugColor debug_color){
//    debug_color.is_set = false;
//    orig = orig.xzy;
//    orig.z *= -1.0;
//    dir = dir.xzy;
//    dir.z *= -1.0;
//    ivec3 cell = ivec3(floor(orig + 0.));
//    vec3 inv_dir = 1 / dir;
//    if(dir.x == 0){
//        inv_dir.x = 1e30;
//    }
//    if(dir.y == 0){
//        inv_dir.y = 1e30;
//    }
//    if(dir.z == 0){
//        inv_dir.z = 1e30;
//    }
//    vec3 delta_dist = abs(inv_dir);
//
//    ivec3 ray_step = ivec3(sign(dir));
//    vec3 side_dist = (sign(dir) * (vec3(cell) - orig) + (sign(dir) * 0.5) + 0.5) * delta_dist;
//    uvec3 resolution = uvec3(32u,32u,32u);
//    bvec3 mask = bvec3(false,false,false);
//    int i = 0;
//    ivec3 very_old_cell = cell;
//    ivec3 old_cell = cell;
//    if(max_v(abs(dir)) == 0){
//        debug_color.is_set = true;
//        debug_color.color = vec4(1.0,1.0,1.0,1.0);
//        return false;
//    }
//    bool at_start = true;
//    while (i < 1000 || true) {
//        very_old_cell = old_cell;
//        old_cell = cell;
//        if(!inside_chunk(cell)){
//            return false;
//        }
//
//
//        if (get_bitmask(bitmask, cell)){
//            float t = length(vec3(mask) * (side_dist - delta_dist)) / length(dir);
//            voxel_index = to_voxel_idx(cell);
//            orig.z *= -1.0;
//            dir.z *= -1.0;
//            cell.z *= -1;
//            dir = dir.xzy;
//            orig = orig.xzy;
//            mask = mask.xzy;
//            cell = cell.xzy;
//
//            vec3 endpoint;
//            if(mask.x){
//                hit_normal = dot(vec3(1.0,0.0,0.0), dir) < 0.0 ? vec3(1.0,0.0,0.0) : vec3(-1.0,0.0,0.0);
//
//                endpoint = orig + dir * t;
//                texcoord = endpoint.zy;
//            }
//            else if(mask.z){
//                hit_normal =  dot(vec3(0.0,0.0,1.0), dir) < 0.0 ? vec3(0.0,0.0,1.0) : vec3(0.0,0.0,-1.0);
//                endpoint = orig + dir * t;
//                texcoord = endpoint.xy;
//            }
//            else if(mask.y){
//                hit_normal = dot(vec3(0.0,1.0,0.0), dir) < 0.0 ? vec3(0.0,1.0,0.0) : vec3(0.0,-1.0,0.0);
//                endpoint = orig + dir * t;
//                texcoord = endpoint.xz;
//            }
//            final_crossing_T = endpoint;
//
//            return true;
//        }
//
//        //should always happen otherwise?
//        else {
//            mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
//            side_dist += vec3(mask) * delta_dist;
//            cell += ivec3(vec3(mask)) * ray_step;
//
//            if(!any(mask) || old_cell == cell){
//                debug_color.is_set = true;
//                debug_color.color = vec4(1.0,1.0,0.0,1.0);
//                return false;
//            }
//        }
//        if(very_old_cell == cell){
//            debug_color.is_set = true;
//            debug_color.color = vec4(1.0,1.0,1.0,1.0);
//            return false;
//        }
//        at_start = false;
//        i += 1;
//    }
//    debug_color.is_set = true;
//    debug_color.color = vec4(1.0,0.0,1.0,1.0);
//    return false;
//
//}


struct DdaOutput{
    uint voxel_index;
    float t_distance;
    vec3 hit_normal;
    vec2 tex_coord;
    DebugColor debug_color;
};

uint to_voxel_idx_rh(ivec3 idx_rh){
    //we use xyz right handed, x lateral, y vertical, z forward,
    //we need to swap axis first to swap y and z.
    ivec3 idx = idx_rh.xzy;
    //now the axis are in the correct orientation for the data (xz is now xy).
    //but in our coordinates, 0 is the bottom, while in memory, 0 is the top. so z needs to reverse.
    idx.z = int((chunk_width - 1) - idx.z);
    return idx.z * chunk_width * chunk_width + idx.y * chunk_width + idx.x;
}

bool get_bitmask_rh(uint32_array bitmask, in ivec3 cell_xyz_right_handed){
    return get(bitmask, to_voxel_idx_rh(cell_xyz_right_handed));
}



//https://www.shadertoy.com/view/4dX3zl
//https://lodev.org/cgtutor/raycasting.html
bool bitmask_intersect_dda(
    uint32_array bitmask,
    in Ray ray,
    out DdaOutput result){
    result.debug_color.is_set = false;
    ivec3 cell_pos = ivec3(floor(ray.pos + 0.0));
    //delta_dist is the distance the ray has to travel
    //to go from one x-side to the next x-side (or y, or z side).
    vec3 delta_dist = abs(vec3(length(ray.dir)) / ray.dir);
    //TODO hopefully delta_distance gets infinity if ray.dir[n] == 0
    //figure out step directions.
    ivec3 ray_step = ivec3(sign(ray.dir));
    //If the ray direction has a negative x-component, sideDistX is the distance from the ray starting position
    //to the first side to the left, if the ray direciton has a positive x-component the first side to the right is used instead.
    vec3 side_dist = (sign(ray.dir) * (vec3(cell_pos) - ray.pos) + (sign(ray.dir) * 0.5) + 0.5) * delta_dist;
    //use to record which dim used?
//    bvec3 mask = bvec3(false, false, false);
    vec3 fraction = fract(ray.pos);
    float min_fract = min_v(fraction);
    //if comming from outside, should work, but inside?
    bvec3 mask = equal(fraction, vec3(min_fract));
    while(true){
        if (!inside_chunk(cell_pos)){
            return false;
        }
        if(get_bitmask_rh(bitmask, cell_pos)){
            float t = length(vec3(mask) * (side_dist - delta_dist)) / length(ray.dir);
            uint voxel_index = to_voxel_idx_rh(cell_pos);
            vec3 hit_normal;
            vec2 texcoord;
            if (mask.x){
                hit_normal = dot(vec3(1.0, 0.0, 0.0), ray.dir) < 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0);
                texcoord = endpoint(ray, t).zy;
            }
            else if (mask.y){
                hit_normal = dot(vec3(0.0, 1.0, 0.0), ray.dir) < 0.0 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, -1.0, 0.0);
                texcoord = endpoint(ray, t).xz;
            }
            else if (mask.z){
                hit_normal =  dot(vec3(0.0, 0.0, 1.0), ray.dir) < 0.0 ? vec3(0.0, 0.0, 1.0) : vec3(0.0, 0.0, -1.0);
                texcoord = endpoint(ray, t).xy;
            }
            else{
                break;
            }
            result.t_distance = t;
            result.voxel_index = voxel_index;
            result.hit_normal = hit_normal;
            result.tex_coord = texcoord;
            return true;
        }else{
            if (side_dist.x < side_dist.y) {
                if (side_dist.x < side_dist.z) {
                    side_dist.x += delta_dist.x;
                    cell_pos.x += ray_step.x;
                    mask = bvec3(true, false, false);
                }
                else {
                    side_dist.z += delta_dist.z;
                    cell_pos.z += ray_step.z;
                    mask = bvec3(false, false, true);
                }
            }
            else {
                if (side_dist.y < side_dist.z) {
                    side_dist.y += delta_dist.y;
                    cell_pos.y += ray_step.y;
                    mask = bvec3(false, true, false);
                }
                else {
                    side_dist.z += delta_dist.z;
                    cell_pos.z += ray_step.z;
                    mask = bvec3(false, false, true);
                }
            }
        }
    }
    result.debug_color.is_set = true;
    result.debug_color.color = vec4(1.0, 0.0, 1.0, 1.0);
    return false;
}

void main(){
    uvec2 pixel_idx = gl_GlobalInvocationID.xy;

    if(pixel_idx.x >= u_resolution.x || pixel_idx.y >= u_resolution.y){
        return;
    }

    //float focus_dist = u_view_state.focus_dist;//max(u_focus_dist + cos(2.0 * (float(u_frame_idx % 1000) / 1000.0) - 1.0) * 10.0, 0.1);
    float fov = u_fov;
    uint tidx = gl_GlobalInvocationID.x;
    uvec2 frag_coord = pixel_idx;
    uvec2 resolution = u_resolution;
    if (frag_coord.x >= u_resolution.x || frag_coord.y >= u_resolution.y){
        return;
    }

    vec3 total_color = vec3(0.0);
    vec3 camera_rotation = u_camera_rotation;
    camera_rotation.x *= -1.0;
    vec3 camera_up = rotate_dir(vec3(0.0,1.0,0.0), camera_rotation);
    vec3 camera_side =  rotate_dir(vec3(1.0,0.0,0.0), camera_rotation);
    vec3 camera_forward = rotate_dir(vec3(0.0,0.0,1.0), camera_rotation);

    Ray ray = create_Ray((vec2(frag_coord)/ (resolution)), resolution, u_camera_origin , camera_rotation, fov);\
    DdaOutput dda_output;
    dda_output.debug_color.is_set = false;
    float intersect_t = inf;
    CornerAABB box = CornerAABB(vec3(0.0),vec3(32.0));
    float t_min = 0;
    float t_max = inf;
    float t = inf;
    if(intersect(ray, box, t_min, t_max, t)){
        Ray new_ray = to_endpoint(ray, t + 0.001);
        if(bitmask_intersect_dda(u_bitmask, new_ray, dda_output)){
            intersect_t = dda_output.t_distance;
        }
    }
    imageStore(u_output_image[u_frame_idx % IMAGE_COUNT], ivec2(frag_coord), vec4(intersect_t,1.0,1.0,1.0));


}

