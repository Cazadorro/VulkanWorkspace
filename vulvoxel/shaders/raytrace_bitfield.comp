#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup: enable
//#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable
#extension GL_EXT_nonuniform_qualifier : enable

//#include "mathutils.glsl"
//#include "basicreftypes.glsl"
//#include "bitmask.glsl"
//#include "bounds.glsl"
#include "raytracingutils.glsl"
#include "mathconstants.glsl"
#include "chunk_render_utils.glsl"
#include "basicreftypes.glsl"
#include "bitmask.glsl"
#include "algorithm.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout (constant_id = 0) const int IMAGE_COUNT = 3;
layout(set = 0, binding = 0) uniform UniformBufferObject {
    uvec2 u_resolution;
    float u_fov;
    float u_focus_distance;
};

layout(set = 0, binding = 1, r32f) uniform writeonly image2D u_output_image[];

layout(push_constant, scalar) uniform PushConstantBlock{
    vec3 u_camera_origin;
    uint u_frame_idx;
    vec3 u_camera_rotation;
    float u_time;
//32 bytes, max 128 bytes.
    uint32_array u_bitmask;
    uint64_t padding;
};

struct DebugColor{
    bool is_set;
    vec4 color;
};

bool get_bitmask(uint32_array bitmask, ivec3 cell_xyz){
    return get(bitmask, to_voxel_idx(cell_xyz));
}

bool get_bitmask(uint32_array bitmask, uint cell_index){
    return get(bitmask, cell_index);
}


//https://www.shadertoy.com/view/4dX3zl
bool bitmask_intersect_dda(
        uint32_array bitmask,
        vec3 orig,
        vec3 dir,
        vec3 block_offset,
        out uint voxel_index,
        out vec3 final_crossing_T,
        out vec3 hit_normal,
        out vec2 texcoord,
        out float out_t,
        out DebugColor debug_color){
    debug_color.is_set = false;
    orig = orig.xzy;
    orig.z *= -1.0;
    dir = dir.xzy;
    dir.z *= -1.0;
    ivec3 cell = ivec3(floor(orig + 0.));
    vec3 inv_dir = 1 / dir;
    if(dir.x == 0){
        inv_dir.x = 1e30;
    }
    if(dir.y == 0){
        inv_dir.y = 1e30;
    }
    if(dir.z == 0){
        inv_dir.z = 1e30;
    }
    vec3 delta_dist = abs(inv_dir);

    ivec3 ray_step = ivec3(sign(dir));
    vec3 side_dist = (sign(dir) * (vec3(cell) - orig) + (sign(dir) * 0.5) + 0.5) * delta_dist;
    uvec3 resolution = uvec3(32u,32u,32u);
    bvec3 mask = bvec3(false,false,false);
    int i = 0;
    ivec3 very_old_cell = cell;
    ivec3 old_cell = cell;
    if(max_v(abs(dir)) == 0){
        debug_color.is_set = true;
        debug_color.color = vec4(1.0,1.0,1.0,1.0);
        return false;
    }
    bool at_start = true;
    while (i < 1000 || true) {
        very_old_cell = old_cell;
        old_cell = cell;
        if(!inside_chunk(cell)){
            return false;
        }


        if (get_bitmask(bitmask, cell)){
            float t = length(vec3(mask) * (side_dist - delta_dist)) / length(dir);
            voxel_index = to_voxel_idx(cell);
            orig.z *= -1.0;
            dir.z *= -1.0;
            cell.z *= -1;
            dir = dir.xzy;
            orig = orig.xzy;
            mask = mask.xzy;
            cell = cell.xzy;

            vec3 endpoint;
            if(mask.x){
                hit_normal = dot(vec3(1.0,0.0,0.0), dir) < 0.0 ? vec3(1.0,0.0,0.0) : vec3(-1.0,0.0,0.0);

                endpoint = orig + dir * t;
                texcoord = endpoint.zy;
            }
            else if(mask.z){
                hit_normal =  dot(vec3(0.0,0.0,1.0), dir) < 0.0 ? vec3(0.0,0.0,1.0) : vec3(0.0,0.0,-1.0);
                endpoint = orig + dir * t;
                texcoord = endpoint.xy;
            }
            else if(mask.y){
                hit_normal = dot(vec3(0.0,1.0,0.0), dir) < 0.0 ? vec3(0.0,1.0,0.0) : vec3(0.0,-1.0,0.0);
                endpoint = orig + dir * t;
                texcoord = endpoint.xz;
            }
            final_crossing_T = endpoint;

            return true;
        }

        //should always happen otherwise?
        else {
            mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
            side_dist += vec3(mask) * delta_dist;
            cell += ivec3(vec3(mask)) * ray_step;

            if(!any(mask) || old_cell == cell){
                debug_color.is_set = true;
                debug_color.color = vec4(1.0,1.0,0.0,1.0);
                return false;
            }
        }
        if(very_old_cell == cell){
            debug_color.is_set = true;
            debug_color.color = vec4(1.0,1.0,1.0,1.0);
            return false;
        }
        at_start = false;
        i += 1;
    }
    debug_color.is_set = true;
    debug_color.color = vec4(1.0,0.0,1.0,1.0);
    return false;

}


void main(){
    uvec2 pixel_idx = gl_GlobalInvocationID.xy;

    if(pixel_idx.x >= u_resolution.x || pixel_idx.y >= u_resolution.y){
        return;
    }

    //float focus_dist = u_view_state.focus_dist;//max(u_focus_dist + cos(2.0 * (float(u_frame_idx % 1000) / 1000.0) - 1.0) * 10.0, 0.1);
    float fov = u_fov;
    uint tidx = gl_GlobalInvocationID.x;
    uvec2 frag_coord = pixel_idx;
    uvec2 resolution = u_resolution;
    if (frag_coord.x >= u_resolution.x || frag_coord.y >= u_resolution.y){
        return;
    }

    vec3 total_color = vec3(0.0);
    vec3 camera_rotation = u_camera_rotation;
    camera_rotation.x *= -1.0;
    vec3 camera_up = rotate_dir(vec3(0.0,1.0,0.0), camera_rotation);
    vec3 camera_side =  rotate_dir(vec3(1.0,0.0,0.0), camera_rotation);
    vec3 camera_forward = rotate_dir(vec3(0.0,0.0,1.0), camera_rotation);

    Ray ray = create_Ray((vec2(frag_coord)/ (resolution)), resolution, u_camera_origin , camera_rotation, fov);
    DebugColor debug_color;
    debug_color.is_set = false;

    uint cell_position;
    vec3 hit_position;
    vec3 hit_normal;
    vec2 hit_texcoord;
    float intersect_t = inf;
    vec3 offset = vec3(0.0f);
    CenterAABB box = CenterAABB(vec3(0.0),vec3(32.0));
    float t_min = 0;
    float t_max = inf;
    float t = inf;
    if(intersect(ray, box, t_min, t_max, t)){
        Ray new_ray = to_endpoint(ray, t + 0.001);
        if(bitmask_intersect_dda(u_bitmask, new_ray.pos, new_ray.dir, offset,cell_position,hit_position, hit_normal, hit_texcoord, intersect_t,debug_color)){

        }
    }
    imageStore(u_output_image[u_frame_idx % IMAGE_COUNT], ivec2(frag_coord), vec4(intersect_t,1.0,1.0,1.0));


}

