#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
//#extension GL_KHR_shader_subgroup_vote: enable
//#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable

#include "mathutils.glsl"
#include "basicreftypes.glsl"
#include "bitmask.glsl"


#define WORKGROUP_SIZE 1024
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

//TODO addspec const, push const, and dynamic uniform arrays on host side.
layout (constant_id = 0) const int IMAGE_COUNT = 3;
struct RayTracingParameters{
    vec3 offset;
    uint width;
    vec3 roll_pitch_yaw;
    uint height;
    float fov;
    vec3 m_padding;
};

//layout(set = 0, binding = 0, std430) uniform LbmParameters{
//    uint u_width;
//    uint u_height;
//
//    float u_tau;
//    float u_dt;
//
//    float u_trt_wp;
//    float u_trt_wn;
//
//    float u_init_density;
//    float u_padding_0;
//
//    uint32_array u_bitmask;
//    float32_array u_lbm_arrays[2];
//
//};
//should be 8 + 8 + 8 aligned?
layout(set = 0, binding = 0, std430) uniform RayTracingParametersBlock{
    RayTracingParameters u_rt_parameters;
} raytracingParameters[];



layout(set = 0, binding=1, rgba8) uniform image2D output_image[];

layout(push_constant) uniform PushConstantBlock{
    uint u_frame_idx;

};

uvec2 pixel_from_linear(uint linear_idx){
    return uvec2(
    linear_idx % raytracingParameters[u_frame_idx % IMAGE_COUNT].u_rt_parameters.width,
    linear_idx / raytracingParameters[u_frame_idx % IMAGE_COUNT].u_rt_parameters.width);
}
bool pixel_within_image(uvec2 pixel_idx){
    return (pixel_idx.x < raytracingParameters[u_frame_idx % IMAGE_COUNT].u_rt_parameters.width && pixel_idx.y < raytracingParameters[u_frame_idx % IMAGE_COUNT].u_rt_parameters.height);
}
void main(){
    uint tidx = gl_GlobalInvocationID.x;
    uvec2 pixel_idx = pixel_from_linear(tidx);
    ivec2 pos = ivec2(pixel_idx);
    ivec2 dims = ivec2(raytracingParameters[u_frame_idx % IMAGE_COUNT].u_rt_parameters.width, raytracingParameters[u_frame_idx % IMAGE_COUNT].u_rt_parameters.height);
    if(!pixel_within_image(pixel_idx)){
        return;
    }

    imageStore(output_image[u_frame_idx % IMAGE_COUNT], pos, vec4(1.0));
//    if (pixel_idx.x > u_width || pixel_idx.y > u_height || get(u_bitmask, pos, dims)){
//        if(!(x > u_width || y > u_height) && get(u_bitmask, pos, dims)){
//            imageStore(output_visualization[u_imageoutput_idx], pos, vec4(1.0));
//        }
//        return;
//    }
}
