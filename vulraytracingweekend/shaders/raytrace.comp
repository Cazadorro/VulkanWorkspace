#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
#extension GL_KHR_shader_subgroup_clustered: enable
#extension GL_KHR_shader_subgroup_quad: enable
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable
//#extension GL_GOOGLE_include_directive :enable

#include "raytracingutils.glsl"
#include "mathconstants.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
layout (constant_id = 0) const int IMAGE_COUNT = 3;
layout(set = 0, binding=0, rgba8) uniform image2D output_image[];
//128 bytes max.
layout(push_constant) uniform PushConstantBlock{
    vec3 u_camera_origin;
    uint u_image_width;
//    16bytes
    vec3 u_camera_rotation;
    uint u_image_height;
//    32bytes
    float u_fov;
    uint u_frame_idx;
// 40 bytes;
};

vec4 calc_ray_background_color(const in Ray ray) {
    float t = 0.5*(ray.dir.y + 1.0);
    return (1.0-t)*vec4(1.0, 1.0, 1.0, 1.0) + t*vec4(0.5, 0.7, 1.0, 1.0);
}

uvec2 pixel_from_linear(uint linear_idx){
    return uvec2(linear_idx % u_image_width, linear_idx / u_image_width);
}
bool pixel_within_image(uvec2 pixel_idx){
    return (pixel_idx.x < u_image_width && pixel_idx.y < u_image_height);
}

float iqhashIII( uvec2 x ){
    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );
    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );
    return float(n) * (1.0/float(0xffffffffU));
}

vec2 hashwithoutsine23(vec3 p3){
    p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

vec2 jitter_frag_coord(vec2 frag_coord, float time){
    return frag_coord + hashwithoutsine23(vec3(frag_coord, time));
}


const uint SAMPLES_PER_PIXEL = 32;

void main(){
    uint tidx = gl_GlobalInvocationID.x;
    uvec2 frag_coord = pixel_from_linear(tidx);
    ivec2 pos = ivec2(frag_coord);
    ivec2 dims = ivec2(u_image_width, u_image_height);

    uvec2 resolution = uvec2(u_image_width, u_image_height);
    if(!pixel_within_image(frag_coord)){
        return;
    }


    vec3 camera_rotation = u_camera_rotation;
    camera_rotation.x *= -1.0;
    vec4 total_color = vec4(0.0);
    for(int sample_idx = 0; sample_idx < SAMPLES_PER_PIXEL; ++sample_idx){
        //jitter_frag_coord(frag_coord, float(sample_idx))
        Ray ray = create_Ray(jitter_frag_coord(vec2(frag_coord), float(sample_idx)), resolution, u_camera_origin, camera_rotation, u_fov);
//        Ray ray = create_Ray(vec2(frag_coord), resolution, u_camera_origin, camera_rotation, u_fov);
        vec4 color = calc_ray_background_color(ray);
        const uint SPHERES_LEN = 2;
        Sphere spheres[SPHERES_LEN] = Sphere[SPHERES_LEN](
        Sphere(vec3(0.0,0.0,4.0), 0.5),
        Sphere(vec3(0.0,-100.5,1.0), 100)
        );
        //    Sphere sphere = Sphere(vec3(0.0,0.0,4.0), 0.5);

        HitRecord hit_record;
        float closest_t = inf;
        for(int i = 0; i < SPHERES_LEN; ++i){
            Sphere sphere = spheres[i];
            if( intersect(ray, sphere, hit_record) && hit_record.to_object < closest_t){
                //        float t = get_first_surface(hit_record);
                float t = (hit_record.to_object);
                vec3 N = hit_record.normal;
                color.rgb = 0.5*(N + 1);
                closest_t = hit_record.to_object;
            }
        }
        total_color += color;
    }
   total_color /= SAMPLES_PER_PIXEL;


    imageStore(output_image[u_frame_idx % IMAGE_COUNT], pos, total_color);
}
