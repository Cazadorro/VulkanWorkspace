#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
#extension GL_KHR_shader_subgroup_clustered: enable
#extension GL_KHR_shader_subgroup_quad: enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable

#extension GL_KHR_memory_scope_semantics : enable
#pragma use_vulkan_memory_model

#include "brush_utils.glsl"
#include "stylus_utils.glsl"
#include "tile_utils.glsl"
#include "blend_utils.glsl"
#include "bitutils.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;



//TODO don't know the consequences of doing something like this?
//layout(buffer_reference, buffer_reference_align=4*32*32, scalar) buffer ColorData_ref {
//    u8vec8 color_data[32*32];
//};



layout(set = 0, binding = 0, scalar) uniform UniformCanvasSettingsBlock{
    uvec2 u_canvas_size;
    CounterData_ref u_counter_data;
    TileMemoryData_ref u_tile_memory;
    BrushSettings_ref u_brushes;
//4 * 8 = 32 bytes
};
//layout(set = 0, binding = 1, rgba8) uniform image2D output_image[];

//layout(push_constant) uniform PushConstantBlock {
//    StylusUpdate_ref u_stylus_updates;  // structure of arrays of all the previous transforms.
//    TileArenaPointerList_ref u_tile_arena_pointers;
//    BrushSettings_ref u_brushes;
//    TileMap_ref u_tiles;
//    CounterData_ref u_counter_data;
//    TileIndex_ref u_updated_tile_index_list;
//    TileHasValueBitArrayList_ref u_tile_arena_has_value_bitarrays;
////48 bytes
//    vec4 u_brush_color;
////64 bytes,
//    uint u_brush_id;
//    uint u_stylus_update_count;
//    uint u_brush_tip_count; //how many times brush actually hit; maybe not need though, could calculate this our selves?
//    uint pc_padding;
////80 bytes.
//};

//TODO should this even be in a push constant? looks like all the ref settings stuff should be in a uniform buffer
//
layout(push_constant) uniform PushConstantBlock {
    StylusUpdate_ref u_stylus_updates;  // structure of arrays of all the previous transforms.
    TileMap_ref u_tiles;
    TileIndex_ref u_updated_tile_index_list;
//3 * 8 bytes
    vec4 u_brush_color;
//5 * 8 bytes,
    uint u_brush_id;
    uint u_stylus_update_count;
    uint u_brush_tip_count; //how many times brush actually hit; maybe not need though, could calculate this our selves?
    uint u_padding; // not used for this shader.
//7 * 8 bytes.= 56 bytes.
//    vec2 brush_start_pos; //initial starting position for where
//maybe not necssary, could instead take another "faked" brush update from the previous brush
//  and put it into stylus update queue.
};


// 64 bytes per stylus update, pre-load stylus updates, as they all need to be checked anyway
// load into shared, load 128 at a time (some warps will have to wait) 8k memory? Or maybe even modify it
//(since every value is a float) based on how many of the properties are even used by the brush?
//Check if values even cover area?
// 128 (8k) of actual stylus updates
// 128 (512) of bboxes?
// prechecks for each warp if bboxes even intersect warp area (32 warps, can use entire set of warps to check per warp, 32 x 128 instances of work)
// this means tile list also needs to be added (32 x 4 = 128 bytes).
// will also want to load brush in?

const uint CACHED_STYLUS_UPDATE_COUNT = 64;
//TODO have stylus distance be a different metric?
//TODO have all stylus attributes be SOA-ized?

// 16 * 4 = 64 * sizeof(StylusUpdate) (64) = 4096 bytes;
shared StylusUpdate shared_stylus_updates[CACHED_STYLUS_UPDATE_COUNT];
shared BrushSettings shared_brush; // += size of shared brush.


//Note these functions are defined *below main* for readability. Many of these functions cannot be put into seperate files because
//they read shared memory/global memory, meaning they are dependent on the variables availible in the scope of this compute shader
// Ideally you don't need to know the definition of these functions
uint find_shared_stylus_update_start_interpolation_index(uint stylus_update_count,  uint tip_index, float spacing);
TileBbox create_interp_bbox(const in BrushSettings brush, uvec2 image_size, uint stylus_interp_idx, uint tip_index, float spacing);
vec2 shared_stylus_interp_pos(uint stylus_interp_idx, float interpolant);
float shared_stylus_interp_normal_pressure(uint stylus_interp_idx, float interpolant);
vec2 shared_stylus_interp_tilt(uint stylus_interp_idx, float interpolant);
void shared_load_next_stylus_updates(uint stylus_load_itr);
vec4 render_brush_tip(uint broadcast_interp_idx,  uint broadcast_interpolation_distance, vec2 pixel_center_pos,
                      vec4 brush_color, vec4 float_color_data);
uint update_brush_tips_left(uint stylus_load_itr, uint brush_tips_left);





const uint TIP_INDEX_OUT_OF_BOUNDS = 0xFFFFFFFF;

void main() {
    uint updated_tile_count = u_counter_data.data[0].updated_tile_count;
    uint global_subgroup_idx = gl_WorkGroupID * gl_NumSubgroups + gl_SubgroupID;
    bool subgroup_tile_in_bounds = global_subgroup_idx < updated_tile_count;
    uint thread_idx = gl_GlobalInvocationIndex;
    uvec2 tile_size = ceil(u_canvas_size, TILE_DATA_WIDTH);
    vec4 brush_color = clamp(u_brush_color, 0.0, 1.0);

    if(gl_LocalInvocationIndex == 0u){
        shared_brush = u_brushes.data[u_brush_id];
    }

    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsShared, gl_SemanticsAcquireRelease);

    uint brush_tips_left = u_brush_tip_count;

    // should do a broadcast load per warp. each warp handles a single tile, so only one tile id per warp.
    uint tile_and_bit_idx = (subgroup_tile_in_bounds) ? u_updated_tile_index_list.data[global_subgroup_idx] : TILE_INVALID;
    uint tile_idx = tile_and_bit_idx & ~TILE_IDX_NEW_BIT;
    bool is_new_tile = ((tile_and_bit_idx & TILE_IDX_NEW_BIT) == TILE_IDX_NEW_BIT);
    bool was_new_tile = is_new_tile;
    uint tile_x = tile_idx / tile_size.x;
    uint tile_y = tile_idx % tile_size.x;
    float brush_tip_spacing = shared_brush.spacing;
    bool column_empty = true;
    //TODO need to load into pointer the actual tile location
    TileArena_ref tile_reference = TileArena_ref(0);
    if(tile_and_bit_idx != TILE_INVALID){
        uint tile_arena_handle = u_tiles.data[tile_idx];
        uint arena_index = TILE_ARENA_BITS & tile_arena_handle >> 16;
        uint arena_tile_index = tile_arena_handle & ARENA_TILE_BITS;
        TileArena_ref tile_arena_reference = u_tile_memory.data[0].area_pointers.data[arena_index];
        //Note will still need to use .data[0]
        tile_reference = tile_arena_reference[arena_tile_index];
    }

    uint stylus_update_load_iterations = 1;
    if(u_stylus_update_count > CACHED_STYLUS_UPDATE_COUNT){
        //CACHED_STYLUS_UPDATE_COUNT - 1 because we need to keep the previous update value to figure out interpolation properly.
        stylus_update_load_iterations += ceil((u_stylus_update_count - CACHED_STYLUS_UPDATE_COUNT), CACHED_STYLUS_UPDATE_COUNT - 1);
    }

    const uint last_cached_stylus_index = CACHED_STYLUS_UPDATE_COUNT - 1;

    uint brush_tip_count_left = u_brush_tip_count;
    for(uint stylus_load_itr = 0; stylus_load_itr < stylus_update_load_iterations; ++stylus_load_itr){

        shared_load_next_stylus_updates(stylus_load_itr);
        // resetting because value is always loaded back for column,
        // resetting gaurantees at end we *actually* know if empty.
        //TODO fix this, should probably find a better way to ensure always checked.
        column_empty = true;
        for (uint tile_row_idx = 0; tile_row_idx < TILE_DATA_HEIGHT; ++i){
            uint tile_col_idx = gl_SubgroupInvocationID;
            if(tile_and_bit_idx == TILE_INVALID){ //applies subgroup wide, so it's safe to do this here with out synchronoizing in subgroup.
                break;
            }
            //if we were flagged as creating a new tile from previous kernels, set value to zero initially.
            vec4 uint_color_data = is_new_tile ? u8vec4(0u) : tile_reference.data[tile_row_idx * TILE_DATA_WIDTH + tile_col_idx];
            //converting from normalized uint according to OpenGL spec https://www.khronos.org/opengl/wiki/Normalized_Integer
            vec4 float_color_data = vec4(uint_color_data.r, uint_color_data.g, uint_color_data.b, uint_color_data.a) / 255.0f;

            //floating point pixel center (so center of pixel 0,0 is 0.5, 0.5) in fractional canvas pixel coordinates.
            vec2 pixel_center_pos = vec2(tile_x * TILE_DATA_WIDTH + tile_col_idx, tile_y * TILE_DATA_HEIGHT + tile_row_idx) + vec2(0.5);



            //for each group of 32 brush tips, rounded up (so 15 brush tips would still count as 1 iteration).
            for(uint brush_tip_grouping = 0; brush_tip_grouping < ceil(brush_tip_count_left, gl_SubgroupSize); ++brush_tip_grouping){
                subgroupBarrier();

                uint brush_tip_index = brush_tip_grouping * gl_SubgroupSize + gl_SubgroupInvocationID;
                uint stylus_interp_idx = TIP_INDEX_OUT_OF_BOUNDS;
                bool brush_tip_bbox_intersects_tile = false;
                if(subgroup_brush_tip_idx < u_brush_tip_count){
                    stylus_interp_idx = find_shared_stylus_update_start_interpolation_index(u_stylus_update_count, subgroup_brush_tip_idx, brush_tip_spacing);
                    //it's possible to reach for an update out-side of the range of the cached stylus update
                    //once this happens we will need to wait later or go through entire thing, store, load?
                    // will need to enter another loop if this happens.
                    if(stylus_interp_idx < last_cached_stylus_index){ // brush_tip_bbox_intersects_tile since false by default don't need to explicity set it here.
                        TileBbox bbox = create_interp_bbox(shared_brush, u_canvas_size, stylus_interp_idx, brush_tip_index, brush_tip_spacing);
                        brush_tip_bbox_intersects_tile = !(iter_tile_and_bit_idx == TILE_INVALID) && (iter_tile_x >= bbox.left_x) && (iter_tile_x <= bbox.right_x)
                        && (iter_tile_y >= bbox.top_y) && (iter_tile_y <= bbox.bot_y);
                    }
                }
                subgroupBarrier();
                uint subgroup_tips_intersect_mask =  subgroupBallot(brush_tip_bbox_intersects_tile).x;
                while(subgroup_tips_intersect_mask != 0u){
                    //broadcast the first box which we actually intersect with.
                    uint broadcast_invocation_id =  findLSB(subgroup_tips_intersect_mask);
                    //no longer need to process this value in the mask, so remove it from next iteration.
                    subgroup_tips_intersect_mask = clear_bit(subgroup_tips_intersect_mask, broadcast_invocation_id);
                    //no need to litterally broadcast this value, can derive it locallly.
                    uint broadcast_tip_index = brush_tip_grouping * gl_SubgroupSize + broadcast_invocation_id;
                    //the base interpolation index.
                    uint broadcast_interp_idx = subgroupBroadcast(stylus_interp_idx, broadcast_invocation_id);

                    float broadcast_tip_distance = broadcast_tip_index * spacing;
                    float broadcast_interpolation_distance = broadcast_tip_distance - shared_stylus_updates[broadcast_interp_idx].distance;


                    float_color_data = render_brush_tip(broadcast_interp_idx, broadcast_interpolation_distance,
                                                        pixel_center_pos, brush_color, float_color_data);
                } // end subgroup_tips_intersect_mask check.
            }// end uint brush_tip_grouping iter
            //check if out of bounds, set to zero, but otherwise still have the invocation participate.
            //note *writeing* more than the canvas size is supportted, tile still 32x32 even if usable pixels
            //doesn't encompass whole scene.
            uvec2 pixel_pos = uvec2(tile_x * TILE_DATA_WIDTH + tile_col_idx, tile_y * TILE_DATA_HEIGHT + tile_row_idx);
            if(pixel_pos.x > u_canvas_size.x || pixel_pos.y > u_canvas_size.y){
                color_data = vec4(0.0f);
            }
            if (color_data.a != 0u){
                column_empty = false;
            }
            //convert color data back into normalized uint.
            //TODO round nearest integer?
            //TODO do we even *want* to deal with integer conversions, instead of just clamping and ceiling and calling it a day?
            //do everything in 0->255 space?
            // or do / 255, and multiply by 256? if we want to do in normalized space, 256 seems to make the most sense.
            // https://www.reddit.com/r/gamedev/comments/4ij5ih/new_realtime_text_rendering_technique_based_on/d2ytegt/
            float_color_data *= 256.0f;
            float_color_data = clamp(float_color_data, 0.0f, 255.0f);
            uint_color_data = u8vec4(float_color_data.r, float_color_data.g, float_color_data.b, float_color_data.a);

            tile_reference.data[tile_row_idx * TILE_DATA_WIDTH + tile_col_idx] = uint_color_data;
        } // end tile_row_idx loop

        is_new_tile = false;
        brush_tips_left = update_brush_tips_left(stylus_load_itr, brush_tips_left);
    }
    if(tile_and_bit_idx != TILE_INVALID){
        subgroupBarrier();
        uint empty_column_mask = subgroupBallot(column_empty).x;
        bool entire_tile_empty = empty_column_mask == 0xFFFFFFFFu;
        if(subgroupElect()){ // only need leading subgoup invocation to do things.
            //if column_empty clear
            //if was_new_tile set bitmask.
            uint tile_arena_handle = u_tiles.data[tile_idx];
            uint arena_index = TILE_ARENA_BITS & tile_arena_handle >> 16;
            uint arena_tile_index = tile_arena_handle & ARENA_TILE_BITS;
            TileHasValueBitArray_ref tile_bit_array_reference =  u_tile_memory.data[0].arena_valid_tile_bitmasks.data[arena_index];
            //Note will still need to use .data[0]
            uint tile_word_bit_mask = ~(1u << (arena_tile_index % 32));
            if (entire_tile_empty){
                //while 1:1 doing things with given tile, the value accessed is a single bit inside of a 32bit integer, which
                //*may* be accessed at the same time from seperate threads.
                uint zero_tile_word_bit_mask = ~tile_word_bit_mask;
                uint previous_mask = atomicAnd(tile_bit_array_reference.data[arena_tile_index / 32], zero_tile_word_bit_mask, gl_ScopeDevice, gl_StorageSematicsBuffer, gl_SemanticsRelaxed);
                if((previous_mask & tile_word_bit_mask) == tile_word_bit_mask){
                    atomicAdd(u_tile_memory.data[0].arena_meta_data.data[arena_index].tile_count, -1, gl_ScopeDevice, gl_StorageSematicsBuffer, gl_SemanticsRelaxed);
                }
            }else if(was_new_tile){
                atomicOr(tile_bit_array_reference.data[arena_tile_index / 32], tile_word_bit_mask, gl_ScopeDevice, gl_StorageSematicsBuffer, gl_SemanticsRelaxed);
                atomicAdd(u_tile_memory.data[0].arena_meta_data.data[arena_index].tile_count, 1, gl_ScopeDevice, gl_StorageSematicsBuffer, gl_SemanticsRelaxed);
            }
        }
    }


    if(gl_GlobalInvocationIndex == 0u){
        //make sure that this thread is the only one out of the whole invocation to update this.
        u_counter_data.data[0].latest_avilible_tile_idx +=  u_counter_data.data[0].new_tile_count;
        //I guess we can manually set these two to zero? via transfer/memory commands?
//        u_counter_data.data[0].new_tile_count = 0;
//        u_counter_data.data[0].updated_tile_count = 0;
    }

    // TODO how to defrag data? can occasionally just copy to seperate area, but then would need to be "locked".
    // TODO need to tell bitmask stuff has been filled for given data.
}



uint find_shared_stylus_update_start_interpolation_index(uint stylus_update_count,  uint tip_index, float spacing){
    if(stylus_update_count == 1u){
        return 0u;
    }
    int end_interp_idx = 0;
    int start_interp_idx = 1;
    float tip_distance = tip_index * spacing;
    if(stylus_update_count > 2u){
        //binary search for stylus update with distance <= tip_distance.
        int low_idx = 0;
        int high_idx = int(stylus_update_count);
        while (low_idx < high_idx){
            //https://zhu45.org/posts/2018/Jan/12/how-to-write-binary-search-correctly/
            //http://coldattic.info/post/95/
            //https://stackoverflow.com/questions/504335/what-are-the-pitfalls-in-implementing-binary-search
            int mid_idx = low_idx + (high_idx - low_idx) / 2;
            //note it should be impossible for distance to be less than 0, and our tip distance should never be less than zero. \
            // int should save us from accidental underflow.
            if (shared_stylus_updates[mid_idx].distance <= tip_distance) {
                low_idx = mid_idx + 1;
            } else { // stylus_updates.data[mid_idx].distance > tip_distance
                high_idx = mid_idx;
            }
        }
        //high should never be 0.
        end_interp_idx = high;
        start_interp_idx = high - 1;
    }
    return start_interp_idx;
}

//TileBbox create_bbox(const in BrushSettings brush, vec2 pos, uint tile_dim_px, uvec2 image_size, float stylus_radius_modifier)
TileBbox create_interp_bbox(const in BrushSettings brush, uvec2 image_size, uint stylus_interp_idx, uint tip_index, float spacing){
    float tip_distance = tip_index * spacing;
    float start_stylus_distance = shared_stylus_updates[stylus_interp_idx].distance;
    float interpolant = tip_distance - start_stylus_distance;
    //only extracting data relevant to bbox creation.
    float normal_pressure = mix(shared_stylus_updates[stylus_interp_idx].normal_pressure, shared_stylus_updates[end_interp_idx].normal_pressure, interpolant);
    float stylus_x = mix(shared_stylus_updates[stylus_interp_idx].x, shared_stylus_updates[stylus_interp_idx + 1].x, interpolant);
    float stylus_y = mix(shared_stylus_updates[stylus_interp_idx].y, shared_stylus_updates[stylus_interp_idx + 1].y, interpolant);
    vec2 stylus_pos = vec2(stylus_x,stylus_y);
    return create_bbox(brush, stylus_pos, TILE_DATA_WIDTH,  image_size, normal_pressure);
}

vec2 shared_stylus_interp_pos(uint stylus_interp_idx, float interpolant){
    float stylus_x = mix(shared_stylus_updates[stylus_interp_idx].x, shared_stylus_updates[stylus_interp_idx + 1].x, interpolant);
    float stylus_y = mix(shared_stylus_updates[stylus_interp_idx].y, shared_stylus_updates[stylus_interp_idx + 1].y, interpolant);
    return vec2(stylus_x,stylus_y);
}

float shared_stylus_interp_normal_pressure(uint stylus_interp_idx, float interpolant){
    return mix(shared_stylus_updates[stylus_interp_idx].normal_pressure, shared_stylus_updates[stylus_interp_idx + 1].normal_pressure, interpolant);
}

vec2 shared_stylus_interp_tilt(uint stylus_interp_idx, float interpolant){
    float stylus_x = mix(shared_stylus_updates[stylus_interp_idx].x_tilt, shared_stylus_updates[stylus_interp_idx + 1].x_tilt, interpolant);
    float stylus_y = mix(shared_stylus_updates[stylus_interp_idx].y_tilt, shared_stylus_updates[stylus_interp_idx + 1].y_tilt, interpolant);
    return vec2(stylus_x,stylus_y);
}


void shared_load_next_stylus_updates(uint stylus_load_itr){
    //don't think we need memory barrier *before*
    uint thread_id =  gl_LocalInvocationIndex;
    if(stylus_load_itr == 0){
        for (uint i = thread_id; i < min(CACHED_STYLUS_UPDATE_COUNT, u_stylus_update_count); i += gl_WorkGroupSize.x){
            uint tip_index = i;
            shared_stylus_updates[i] = u_stylus_updates.data[i];
        }
    }else{
        if(thread_id == 0){
            //move the last value used to the begining, we need it to properly interpolate.
            shared_stylus_updates[0] = shared_stylus_updates[CACHED_STYLUS_UPDATE_COUNT - 1u];
        }
        //need memory barrier so we make sure stuff from last element copied to the first is copied first.
        memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsShared, gl_SemanticsAcquireRelease);
        for (uint i = thread_id + 1; i < min(CACHED_STYLUS_UPDATE_COUNT, u_stylus_update_count); i += gl_WorkGroupSize.x){
            uint tip_index = i;
            shared_stylus_updates[i] = u_stylus_updates.data[i];
        }
    }
    //We do need a memory barrier after to make sure data is now visible to all threads in local work group.
    memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsShared, gl_SemanticsAcquireRelease);
}


vec4 render_brush_tip(uint broadcast_interp_idx, uint broadcast_interpolation_distance,
                      vec2 pixel_center_pos, vec4 brush_color, vec4 float_color_data){
    //TODO handle different parameters differently.
    if (shared_brush.shape == BRUSH_SHAPE_CIRCLE){

        //TODO handle mutli sampling
        if (shared_brush.fade_type == BRUSH_FADE_LINEAR){
            vec2 brush_tip_pos = shared_stylus_interp_pos(broadcast_interp_idx, broadcast_interpolation_distance);

            float pixel_distance = distance(brush_tip_pos, pixel_center_pos);

            //TODO handle non linked fade
            float fade = shared_brush.fade_parameter.x;

            float radius = shared_brush.diameter / 2.0f;
            //TODO actually look up in brush settings what effects the size etc...
            radius *= shared_stylus_interp_normal_pressure(broadcast_interp_idx, broadcast_interpolation_distance);

            float normalized_distance = pixel_distance / radius;

            float alpha_adjustment = (normalized_distance - fade);
            vec4 adjusted_color = brush_color;
            adjusted_color.a *= alpha_adjustment;
            float_color_data.rgb = (float_color_data.rgb + (1.0 - adjusted_color.a)) + adjusted_color.rgb * adjusted_color.a;
            float_color_data.a += adjusted_color.a;

        }
    }
    return float_color_data;
}

uint update_brush_tips_left(uint stylus_load_itr, uint brush_tips_left){
    if(stylus_load_itr == 0u){
        brush_tips_left = CACHED_STYLUS_UPDATE_COUNT > brush_tips_left ? 0 : brush_tips_left - CACHED_STYLUS_UPDATE_COUNT;
    }else{
        //if itr is more than 0, we only loaded in 63 values.
        brush_tips_left = CACHED_STYLUS_UPDATE_COUNT > brush_tips_left ? 0 : brush_tips_left - (CACHED_STYLUS_UPDATE_COUNT - 1);
    }
    return brush_tips_left;
}