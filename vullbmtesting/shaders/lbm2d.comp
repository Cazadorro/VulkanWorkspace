#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup: enable
//#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable

#include "mathutils.glsl"
#include "basicreftypes.glsl"
#include "bitmask.glsl"
//#include "bounds.glsl"

#define WORKGROUP_SIZE 1024
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

const uint LBM_DIR_COUNT = 9;
const uint LBM_IDX_NW = 0;
const uint LBM_IDX_NM = 1;
const uint LBM_IDX_NE = 2;
const uint LBM_IDX_WW = 3;
const uint LBM_IDX_MM = 4;
const uint LBM_IDX_EE = 5;
const uint LBM_IDX_SW = 6;
const uint LBM_IDX_SM = 7;
const uint LBM_IDX_SE = 8;

//weights for equilibrium for each direction type
float cardinal_weight = 1.0/9.0;
float ordinal_weight = 1.0/36.0;
float middle_weight = 4.0/9.0;


float weights[LBM_DIR_COUNT] = float[](
ordinal_weight, cardinal_weight, ordinal_weight,
cardinal_weight, middle_weight, cardinal_weight,
ordinal_weight, cardinal_weight, ordinal_weight
);

uint opposite_idxs[LBM_DIR_COUNT] = uint[](
LBM_IDX_SE, LBM_IDX_SM, LBM_IDX_SW,
LBM_IDX_EE, LBM_IDX_MM, LBM_IDX_WW,
LBM_IDX_NE, LBM_IDX_NM, LBM_IDX_NW
);

ivec2 stream_offsets[LBM_DIR_COUNT] = ivec2[](
ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
ivec2(-1, 0), ivec2(0, 0), ivec2(1, 0),
ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1)
);

vec2 velocities[LBM_DIR_COUNT] = vec2[](
vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
vec2(-1.0, 0.0), vec2(0.0, 0.0), vec2(1.0, 0.0),
vec2(-1.0, 1.0), vec2(0.0, 1.0), vec2(1.0, 1.0)
);

float c = 0.5773502691896257645091487805019574556476017512701268760186023264;
float c_2 = 0.3333333333333333333333333333333333333333333333333333333333333333;

uint toLinear(ivec2 pos, uint width){
    return pos.y * width + pos.x;
}

bool inBounds(uvec2 pos, uvec2 dims){
    return pos.x < dims.x && pos.y < dims.y;
}

bool inBounds(ivec2 pos, ivec2 dims){
    return pos.x >= 0 &&  pos.y >= 0 && pos.x < dims.x && pos.y < dims.y;
}

////TODO see if this can fit inside an include instead?
//layout(buffer_reference, buffer_reference_align=4, scalar) buffer float32_array{
//    float32_t data[];
//};

//should be 8 + 8 + 8 aligned?
layout(set = 0, binding = 0, std430) uniform LbmParameters{
    uint u_width;
    uint u_height;

    float u_tau;
    float u_dt;

    float u_trt_wp;
    float u_trt_wn;

    float u_init_density;
    float u_padding_0;

    uint32_array u_bitmask;
    float32_array u_lbm_arrays[2];

};

vec2 u_force = vec2(0.0, 0.000000);

layout(set = 0, binding=1, RGBA32F) uniform image2D output_visualization[];

const uint LBM_CLICK_EVENT_TYPE_UNCLICKED = 0;
const uint LBM_CLICK_EVENT_TYPE_VELOCITY = 1;
const uint LBM_CLICK_EVENT_TYPE_ADD_BITMASK = 2;
const uint LBM_CLICK_EVENT_TYPE_REMOVE_BITMASK= 3;
layout(push_constant) uniform PushConstantBlock{
    uint u_iteration_idx;
    uint u_imageoutput_idx;
    uint u_click_event;
    float u_click_radius;
    float u_click_magnitude;
    float u_other_padding;
    vec2 u_click_coordinate;
    vec2 u_click_direction;
};

float32_array getInput(){
    return u_lbm_arrays[u_iteration_idx % 2];
}

float32_array getOutput(){
    return u_lbm_arrays[(u_iteration_idx+1) % 2];
}

float getInputFor(uint frame, ivec2 pos){
    uint frame_offset = (u_width * u_height) * frame;

    return getInput().data[frame_offset + toLinear(pos, u_width)];
}
float getBounceInputFor(uint frame, ivec2 pos){
    uint opposite_frame = opposite_idxs[frame];
    uint frame_offset = (u_width * u_height) * opposite_frame;
    return getInput().data[frame_offset + toLinear(pos, u_width)];
}

float getCheckedInputFor(uint frame, ivec2 pos, ivec2 dims){
    ivec2 offset_pos = pos - stream_offsets[frame];
    if (inBounds(offset_pos, dims) && (!get(u_bitmask, offset_pos, dims))){
        return getInputFor(frame, offset_pos);
    } else {
        return getBounceInputFor(frame, pos);
    }
}

void setOutput(uint frame, uint linear_idx, float value){
    uint frame_offset = (u_width * u_height) * frame;
    getOutput().data[frame_offset + linear_idx] = value;
}

float calc_equilibrium_incompressable(float density, vec2 velocity, uint i){
    float w_i = weights[i];
    vec2 c_i = velocities[i];
    float cu_i = dot(c_i, velocity);
    float uu = dot(velocity, velocity);
    float f_eq = w_i * density + w_i * u_init_density * (3 *cu_i + (9.0/2.0) * pow2(cu_i) - (3.0/2.0) * pow2(uu));
    return f_eq;
}
float calc_equilibrium(float density, vec2 velocity, uint i){
    float w_i = weights[i];
    vec2 c_i = velocities[i];
    float cu_i = dot(c_i, velocity);
    float uu = dot(velocity, velocity);
    //actually a -3/2 instead of +
    float f_eq = w_i * density * (1 + 3 *cu_i + (9.0/2.0) * pow2(cu_i) - (3.0/2.0) * pow2(uu));
    return f_eq;
}

#define USING_INCOMPRESSIBLE

float calc_force_incompressable(float density, vec2 velocity, uint i){
    float w_i = weights[i];
    vec2 c_i = velocities[i];
    return w_i * dot(c_i, u_force) / c_2;
}

float calc_force(float density, vec2 velocity, uint i){
    float w_i = weights[i];
    vec2 c_i = velocities[i];
    mat2x2 c_i_ab;
    c_i_ab[0][0] = c_i.x * c_i.x - c_2;
    c_i_ab[0][1] = c_i.x * c_i.y;
    c_i_ab[1][0] = c_i.x * c_i.y;
    c_i_ab[1][1] = c_i.y * c_i.y - c_2;
    return w_i *  dot(((c_i / c_2) +(c_i_ab * velocity)/(c_2*c_2)), u_force);
}


float force_equation(float density, vec2 velocity, uint i){
    return calc_force_incompressable(density, velocity, i);
}

float calc_force_source_term(float density, vec2 velocity, uint i){
    float tau_hat = u_tau + u_dt / 2.0;
    return (1.0 - u_dt / (2 * tau_hat)) * force_equation(density, velocity, i);
}

float equilibrium_function(float density, vec2 velocity, uint i){
    #ifdef USING_INCOMPRESSIBLE
    return calc_equilibrium_incompressable(density, velocity, i);
    #else
    return calc_equilibrium(density, velocity, i);
    #endif
}

void main(){
    uint x_idx = gl_GlobalInvocationID.x;
    uint x = x_idx % u_width;
    uint y = x_idx / u_width;
    ivec2 pos = ivec2(x, y);
    ivec2 dims = ivec2(u_width, u_height);
    bool within_bounds = abs(distance(u_click_coordinate, pos)) < u_click_radius;
    uint ballot_result = subgroupBallot(within_bounds)[0];
    if(inBounds(pos, dims)){
        switch (u_click_event){
            case LBM_CLICK_EVENT_TYPE_UNCLICKED: {
                break;
            }
            case LBM_CLICK_EVENT_TYPE_VELOCITY: {
                break;
            }
            case LBM_CLICK_EVENT_TYPE_ADD_BITMASK: {
                if(gl_SubgroupInvocationID == 0){
                    set_chunk(u_bitmask, pos, dims, ballot_result);
                }
                break;
            }
            case LBM_CLICK_EVENT_TYPE_REMOVE_BITMASK: {
                if(gl_SubgroupInvocationID == 0){
                    clear_chunk(u_bitmask, pos, dims, ballot_result);
                }
                break;
            }
        }
    }

    if (!inBounds(pos, dims) || get(u_bitmask, pos, dims)){
        if(inBounds(pos, dims) && get(u_bitmask, pos, dims)){
            imageStore(output_visualization[u_imageoutput_idx], pos, vec4(1.0));
        }
        return;
    }


    float streamed[LBM_DIR_COUNT] = {
        0.0f, 0.0f, 0.0f,
        0.0f, 0.0f, 0.0f,
        0.0f, 0.0f, 0.0f
    };


    for (uint i = 0; i < LBM_DIR_COUNT; ++i){
        streamed[i] = getCheckedInputFor(i, pos, dims);
    }

    //assumes speed of sound is 1/sqrt(3)



    float accum_force;
    float density = 0;
    vec2 momentum = vec2(0.0, 0.0);
    for (uint i = 0; i < LBM_DIR_COUNT; ++i){
        vec2 c_i = velocities[i];
        float value = streamed[i];
//        F_i = force_equation()
        momentum += c_i * value;
        density += value;

    }

    vec2 velocity;
    if(!(density < 0.000001)){
        velocity = momentum / density;
//        velocity += u_force * u_dt / (2 * density);
        if(u_click_event == LBM_CLICK_EVENT_TYPE_VELOCITY){
            if(distance(vec2(pos), u_click_coordinate) < u_click_radius){
                velocity += (u_click_direction) * u_click_magnitude  * u_dt / (2 * density);
            }
        }
    }else{
        velocity = vec2(0.0);
    }
    float tau_hat = u_tau + u_dt / 2.0;

    float mass_conservation_sum = 0.0;
//    #define USE_TRT
    #ifdef USE_TRT
    for (uint i = 0; i < (LBM_DIR_COUNT/2); ++i){
        float f_eq = equilibrium_function(density, velocity, i);
        float f_eq_c = equilibrium_function(density, velocity, opposite_idxs[i]);

        float S_i = calc_force_source_term(density, velocity, i);
        float S_i_c = calc_force_source_term(density, velocity, opposite_idxs[i]);

        float f = streamed[i];
        float f_c = streamed[opposite_idxs[i]];

        float f_p = (f + f_c) / 2; //f+_i
        float f_n = (f - f_c) / 2; //f-_i

        float f_eq_p = (f_eq + f_eq_c) / 2; //f_eq_i +
        float f_eq_n = (f_eq - f_eq_c) / 2; //f_eq_i -

        streamed[i] = f - u_trt_wp * u_dt *(f_p - f_eq_p) - u_trt_wn * u_dt * (f_n - f_eq_n) + S_i * u_dt;
        streamed[opposite_idxs[i]] = f_c - u_trt_wp * u_dt * (f_p - f_eq_p) - u_trt_wn * u_dt * (-f_n + f_eq_n) + S_i_c * u_dt;
    }
    {
        uint i = LBM_IDX_MM;
        float f_eq = equilibrium_function(density, velocity, i);
        float S_i = calc_force_source_term(density, velocity, i);
        float f = streamed[i];

        float f_p = f;//f+_i
        float f_n = 0; //f-_i

        float f_eq_p = f_eq; //f_eq_i +
        float f_eq_n = 0; //f_eq_i -

        streamed[i] = f - u_trt_wp * u_dt * (f_p - f_eq_p) - u_trt_wn * u_dt * (f_n - f_eq_n) + S_i * u_dt;
    }

    #else
    for (uint i = 0; i < LBM_DIR_COUNT; ++i){
        float w_i = weights[i];
        vec2 c_i = velocities[i];
        float cu_i = dot(c_i, velocity);
        float uu = dot(velocity, velocity);
        //actually a -3/2 instead of +

//        float f_eq = w_i * density * (1 + 3 *cu_i + (9.0/2.0) * pow2(cu_i) - (3.0/2.0) * pow2(uu));

        float f_eq = equilibrium_function(density, velocity, i);
        f_eq = w_i * density * (1 + 3 *cu_i + (9.0/2.0) * pow2(cu_i) - (3.0/2.0) * pow2(uu));
        float S_i = calc_force_source_term(density, velocity, i);
//        streamed[i] = max(streamed[i] * (1.0 - (1/u_tau)) + f_eq*(1/u_tau), 0.0);
//        streamed[i] = (streamed[i] * (1.0 - (1/u_tau)) + f_eq*(1/u_tau));
        float tau_hat = u_tau + u_dt / 2.0;
//        streamed[i] += -(u_dt/tau_hat) * (streamed[i] - f_eq) + S_i * u_dt;
        streamed[i] += -(u_dt/u_tau) * (streamed[i] - f_eq); //+ S_i * u_dt;
//        streamed[i] += -(u_dt/u_tau) * (streamed[i] - f_eq) + S_i * u_dt;
//        mass_conservation_sum += streamed[i];
    }
    #endif
//    if(mass_conservation_sum != density){
//        for (uint i = 0; i < LBM_DIR_COUNT; ++i){
////            streamed[i] *= density / mass_conservation_sum;
//        }
//    }

//
    if(u_click_event == LBM_CLICK_EVENT_TYPE_VELOCITY){
        if(distance(vec2(pos), u_click_coordinate) < u_click_radius){
            for (uint i = 0; i < LBM_DIR_COUNT; ++i){
//                streamed[i] += max(dot(velocities[i], u_click_direction) * u_click_magnitude, 0.0);
//                if(i == LBM_IDX_EE){
//                    streamed[i] = u_click_magnitude;
//                }
            }
        }
    }
//


    for (uint i = 0; i < LBM_DIR_COUNT; ++i){
        setOutput(i, toLinear(pos, u_width), streamed[i]);
    }

//

//    float curl = (streamed[LBM_IDX_SM] - streamed[LBM_IDX_NM]) - (streamed[LBM_IDX_EE] - streamed[LBM_IDX_WW]);
    float curl = ((streamed[LBM_IDX_SM] + streamed[LBM_IDX_SE] + streamed[LBM_IDX_SW]) - (streamed[LBM_IDX_NM] + streamed[LBM_IDX_NE] + streamed[LBM_IDX_NW]))
    - ((streamed[LBM_IDX_EE] + streamed[LBM_IDX_NE] + streamed[LBM_IDX_SE]) - (streamed[LBM_IDX_WW] + streamed[LBM_IDX_NW] + streamed[LBM_IDX_SW]));
    if (isinf(velocity.x) || isinf(velocity.y) || isinf(density)){
        imageStore(output_visualization[u_imageoutput_idx], pos, vec4(0.7, 0.7, 0.7, 0.7));
    }
    else if (isnan(velocity.x) || isnan(velocity.y) || isnan(density)){
        imageStore(output_visualization[u_imageoutput_idx], pos, vec4(0.5, 0.5, 0.5, 0.5));
    } else {
//        imageStore(output_visualization[u_imageoutput_idx], pos, vec4(max(density - 10.0, 0.0) * 10.0, abs(velocity.x*(10.0/u_tau)), abs(velocity.y*(10.0/u_tau)), 1.0));
        imageStore(output_visualization[u_imageoutput_idx], pos, vec4(density, velocity.x, velocity.y, 1.0));

        //        if(curl < 0.0){
//            imageStore(output_visualization[u_imageoutput_idx], pos, vec4(max(density - 1000.0, 0.0) * 0.01, abs(curl) * 10.0, 0.0, 1.0));
//        }else{
//            imageStore(output_visualization[u_imageoutput_idx], pos, vec4(max(density - 1000.0, 0.0) * 0.01, 0.0, abs(curl) * 10.0, 1.0));
//        }

    }
    //imageStore(output_visualization[u_imageoutput_idx], ivec2(128,128), vec4(1.0,0.0,1.0,1.0));
}
