#version 450
////https://www.khronos.org/blog/vulkan-subgroup-tutorial
//#extension GL_ARB_separate_shader_objects : enable
//#extension GL_KHR_shader_subgroup_vote: enable
//#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered
//#extension GL_KHR_shader_subgroup_quad
#extension GL_EXT_scalar_block_layout: enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
//for uint64_t etc...
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable



#define WORKGROUP_SIZE 1024
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

const uint LBM_DIR_COUNT = 9;
const uint LBM_IDX_NW = 0;
const uint LBM_IDX_NM = 1;
const uint LBM_IDX_NE = 2;
const uint LBM_IDX_WW = 3;
const uint LBM_IDX_MM = 4;
const uint LBM_IDX_EE = 5;
const uint LBM_IDX_SW = 6;
const uint LBM_IDX_SM = 7;
const uint LBM_IDX_SE = 8;

float cardinal_weight = 1.0/9.0;
float ordinal_weight = 1.0/36.0;
float middle_weight = 4.0/9.0;

float weights[LBM_DIR_COUNT] = float[](
ordinal_weight, cardinal_weight, ordinal_weight,
cardinal_weight, middle_weight, cardinal_weight,
ordinal_weight, cardinal_weight, ordinal_weight
);

uint opposite_idxs[LBM_DIR_COUNT] = uint[](
LBM_IDX_SE, LBM_IDX_SM, LBM_IDX_SW,
LBM_IDX_EE, LBM_IDX_MM, LBM_IDX_WW,
LBM_IDX_NE, LBM_IDX_NM, LBM_IDX_NW
);

ivec2 stream_offsets[LBM_DIR_COUNT] = ivec2[](
    ivec2(-1,-1),ivec2( 0,-1),ivec2( 1,-1),
    ivec2(-1, 0),ivec2( 0, 0),ivec2( 1, 0),
    ivec2(-1, 1),ivec2( 0, 1),ivec2( 1, 1)
);

vec2 velocities[LBM_DIR_COUNT] = vec2[](
vec2(-1.0,-1.0),vec2( 0.0,-1.0),vec2( 1.0,-1.0),
vec2(-1.0, 0.0),vec2( 0.0, 0.0),vec2( 1.0, 0.0),
vec2(-1.0, 1.0),vec2( 0.0, 1.0),vec2( 1.0, 1.0)
);

uint toLinear(ivec2 pos, uint width){
    return y * width + x;
}

bool inBounds(uvec2 pos, uvec2 dims){
    return pos.x < dims.x && pos.y < dims.y;
}

bool inBounds(ivec2 pos, ivec2 dims){
    return pos.x >= 0 &&  pos.y >= 0 && pos.x < dims.x && pos.y < dims.y;
}

//TODO see if this can fit inside an include instead?
layout(buffer_reference, buffer_reference_align=4, scalar) buffer float32_array{
    float32_t data[];
};

layout(set = 0, binding = 0, std430) buffer LbmParameters{
    uint u_width;
    uint u_height;
    float u_tau;
    float u_padding;
    float32_array u_input;
    float32_array u_ouput;
//    float32_array u_input_nw;
//    float32_array u_input_nm;
//    float32_array u_input_ne;
//    float32_array u_input_ww;
//    float32_array u_input_mm;
//    float32_array u_input_ee;
//    float32_array u_input_sw;
//    float32_array u_input_sm;
//    float32_array u_input_se;
//
//    float32_array u_output_nw;
//    float32_array u_output_nm;
//    float32_array u_output_ne;
//    float32_array u_output_ww;
//    float32_array u_output_mm;
//    float32_array u_output_ee;
//    float32_array u_output_sw;
//    float32_array u_output_sm;
//    float32_array u_output_se;
};



layout(std430, binding = 0) buffer LbmParameters{
    uint u_width;
    uint u_height;
    float u_tau;
    float u_padding;
};

layout(std430, binding = 1) buffer LbmInputBlockNW{
    float u_input_nw[];
};

layout(std430, binding = 2) buffer LbmInputBlockNM{
    float u_input_nm[];
};

layout(std430, binding = 3) buffer LbmInputBlockNE{
    float u_input_ne[];
};

layout(std430, binding = 4) buffer LbmInputBlockWW{
    float u_input_ww[];
};

layout(std430, binding = 5) buffer LbmInputBlockMM{
    float u_input_mm[];
};

layout(std430, binding = 6) buffer LbmInputBlockEE{
    float u_input_ee[];
};

layout(std430, binding = 7) buffer LbmInputBlockSW{
    float u_input_sw[];
};

layout(std430, binding = 8) buffer LbmInputBlockSM{
    float u_input_sm[];
};

layout(std430, binding = 9) buffer LbmInputBlockSE{
    float u_input_se[];
};


layout(std430, binding = 10) buffer LbmOutputBlockNW{
    float u_output_nw[];
};

layout(std430, binding = 11) buffer LbmOutputBlockNM{
    float u_output_nm[];
};

layout(std430, binding = 12) buffer LbmOutputBlockNE{
    float u_output_ne[];
};

layout(std430, binding = 13) buffer LbmOutputBlockWW{
    float u_output_ww[];
};

layout(std430, binding = 14) buffer LbmOutputBlockMM{
    float u_output_mm[];
};

layout(std430, binding = 15) buffer LbmOutputBlockEE{
    float u_output_ee[];
};

layout(std430, binding = 16) buffer LbmOutputBlockSW{
    float u_output_sw[];
};

layout(std430, binding = 17) buffer LbmOutputBlockSM{
    float u_output_sm[];
};

layout(std430, binding = 18) buffer LbmOutputBlockSE{
    float u_output_se[];
};



void main(){
    uint x_idx = gl_GlobalInvocationID.x;
    uint x = x_idx % u_width;
    uint y = x_idx / u_width;

    if (x_idx > u_width || y > u_height){
        return;
    }

    float streamed[LBM_DIR_COUNT] = {
        0.0f,0.0f,0.0f,
        0.0f,0.0f,0.0f,
        0.0f,0.0f,0.0f
    };
    ivec2 pos = ivec2(x,y);
    ivec2 dims = ivec2(u_width, u_height);
    if(inBounds(pos + opposite_offsets[LBM_IDX_NW], dims)){
        streamed[LBM_IDX_NW] = u_input_nw[toLinear(pos + opposite_offsets[LBM_IDX_NW], u_width)];
    }else{
        streamed[LBM_IDX_NW] = u_input_
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_NM], dims)){
        streamed[LBM_IDX_NM] = u_input_nm[toLinear(pos + stream_offsets[LBM_IDX_NM], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_NE], dims)){
        streamed[LBM_IDX_NE] = u_input_ne[toLinear(pos + stream_offsets[LBM_IDX_NE], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_WW], dims)){
        streamed[LBM_IDX_WW] = u_input_ww[toLinear(pos + stream_offsets[LBM_IDX_WW], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_MM], dims)){
        streamed[LBM_IDX_MM] = u_input_mm[toLinear(pos + stream_offsets[LBM_IDX_MM], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_EE], dims)){
        streamed[LBM_IDX_EE] = u_input_ee[toLinear(pos + stream_offsets[LBM_IDX_EE], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_SW], dims)){
        streamed[LBM_IDX_SW] = u_input_sw[toLinear(pos + stream_offsets[LBM_IDX_SW], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_SM], dims)){
        streamed[LBM_IDX_SM] = u_input_sm[toLinear(pos + stream_offsets[LBM_IDX_SM], u_width)];
    }
    if(inBounds(pos + stream_offsets[LBM_IDX_SE], dims)){
        streamed[LBM_IDX_SE] = u_input_se[toLinear(pos + stream_offsets[LBM_IDX_SE], u_width)];
    }











    //    LatticeSize lattice_size = LatticeSize(lattice_dimensions.frame_count, lattice_dimensions.row_count, lattice_dimensions.col_count, dir_count);
//    MaskSize mask_size = createMaskSize(lattice_size);
//    streamAndCollide(lattice_size, mask_size, gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z);

}

const uint dir_count = 19;
const float lattice_speed = 1.0;
const float tau = 4.0;
const float bounce_friction = 1.0;


layout(std430, binding = 0) buffer LbmLattice0
{
    float input_array[];
};

layout(std430, binding = 1) buffer LbmLattice1
{
    float output_array[];
};

layout(std430, binding = 2) buffer LbmLattice2
{
    bool mask_array[];
};

layout(RGBA32F, binding=3) uniform image3D output_velocity_density;

layout(push_constant) uniform InputBlockps{
    uint frame_count;
    uint row_count;
    uint col_count;
    uint iteration_count;
}lattice_dimensionsps;

layout(binding = 4) uniform InputBlock{
    uint frame_count;
    uint row_count;
    uint col_count;
    uint iteration_count;
}lattice_dimensions;

struct LatticeSize{
    uint frame_count;
    uint row_count;
    uint col_count;
    uint dir_count;
};

struct MaskSize{
    uint frame_count;
    uint row_count;
    uint col_count;
};

MaskSize createMaskSize(const in LatticeSize lattice_size){
    return MaskSize(lattice_size.frame_count, lattice_size.row_count, lattice_size.col_count);
}

float getLatticeInput(LatticeSize size, uint frame, uint row, uint col, uint dir){
    uint index = frame * (size.row_count * size.col_count * size.dir_count) + row * (size.col_count * size.dir_count) + (col * size.dir_count) + dir;
    return input_array[index];
}

float getLatticeOutput(LatticeSize size, uint frame, uint row, uint col, uint dir){
    uint index = frame * (size.row_count * size.col_count * size.dir_count) + row * (size.col_count * size.dir_count) + (col * size.dir_count) + dir;
    return output_array[index];
}

void setLatticeOutput(LatticeSize size, uint frame, uint row, uint col, uint dir, float value){
    output_array[frame * (size.row_count * size.col_count * size.dir_count) + row * (size.col_count * size.dir_count) + (col * size.dir_count) + dir] = value;
}

bool getMask(MaskSize size, uint frame, uint row, uint col){
    return mask_array[frame * (size.row_count * size.col_count) + row * (size.col_count) + col];
}

void setVelocityDensityOutput(LatticeSize size, uint frame, uint row, uint col, vec3 velocity, float density){
    imageStore(output_velocity_density, ivec3(col, row, frame), vec4(velocity, density));
    //imageStore(output_velocity_density, ivec3(col, row, frame), vec4(1.0));
}


uint opposite_dir(uint dir, uint max_dir){
    int half_max_dir = int(max_dir) / 2;
    return ((int(dir) - (half_max_dir)) * -1) + half_max_dir;
}

float[dir_count] streamValue(LatticeSize size, MaskSize mask_size, uint frame, uint row, uint col) {
    uint dir = 0;
    float[dir_count] dir_output;
    for (int k = -1; k <= 1; ++k) {
        for (int i = -1; i <= 1; ++i) {
            for (int j = -1; j <= 1; ++j) {
                //if we are on a 3d corner
                if (k != 0 && i != 0 && j != 0) {
                    continue;
                }
                int in_frame = int(frame) - k;
                int in_row = int(row) - i;
                int in_col = int(col) - j;

                if (in_frame >= 0 &&
                (frame - k) < size.frame_count &&
                in_row >= 0 &&
                (row - i) < size.row_count
                && in_col >= 0 &&
                (col - j) < size.col_count) {
                    if (getMask(mask_size, in_frame, in_row, in_col)) {
                        float streamed_value = getLatticeInput(size, in_frame, in_row, in_col, dir);
                        //setLatticeOutput(frame, row, col, dir, streamed_value);
                        dir_output[dir] = streamed_value;
                    } else {
                        float streamed_value =  bounce_friction * getLatticeInput(size, frame, row, col, opposite_dir(dir, dir_count));
                        //                        setLatticeOutput(frame, row, col, dir, streamed_value);
                        dir_output[dir] = streamed_value;
                    }
                } else {
                    float streamed_value =  bounce_friction * getLatticeInput(size, frame, row, col, opposite_dir(dir, dir_count));
                    //                    setLatticeOutput(frame, row, col, dir,streamed_value);
                    dir_output[dir] = streamed_value;
                }
                dir += 1;
            }
        }
    }
    return dir_output;
}

//source for equations and weights https://pdfs.semanticscholar.org/e626/ca323a9a8a4ad82fb16ccbbbd93ba5aa98e0.pdf
void altBGKEquilibrium(
LatticeSize size, uint frame, uint row, uint col, float density,
const in vec3 velocity, const in float[dir_count] dir_output) {
    uint dir = 0;
    for (int k = -1; k <= 1; ++k) {
        for (int i = -1; i <= 1; ++i) {
            for (int j = -1; j <= 1; ++j) {
                if (k != 0 && i != 0 && j != 0) {
                    continue;
                }
                float weight;
                if (k == 0 && i == 0 && j == 0) {
                    weight = 1.0 / 3.0;
                } else if (abs(k + i + j) == 1) {
                    weight = 1.0 / 18.0;
                } else {
                    weight = 1.0 / 36.0;
                }

                vec3 current_velocity = vec3(j, i, k);
                float ei_dot_u = dot(current_velocity,
                velocity);

                float u_dot_u = dot(velocity, velocity);

                float equilibrium = weight * density * (1.0f -
                ((3.0f / 2.0f) *
                u_dot_u *
                u_dot_u) +
                (3.0f *
                ei_dot_u) +
                ((9.0f / 2.0f) *
                (ei_dot_u *
                ei_dot_u)));

                float value = dir_output[dir];
                float collisioned_value = value - ((value - equilibrium) *(lattice_speed / tau));
                uint dir_index = uint(dir_count * ((sin(lattice_dimensions.iteration_count) + 1.0)/2.0));
                dir_index = 10u;
                if (dir == dir_index && (lattice_dimensions.iteration_count % 231 < 10) && (frame+row+col) == 0){
                    collisioned_value += 1000.0;
                }
                //collisioned_value += 0.0;
                //                uint dir_index = uint(dir_count * ((sin(lattice_dimensions.iteration_count) + 1.0)/2.0));
                //                dir_index = 10u;
                //                if((lattice_dimensions.iteration_count != 0)){
                //                    collisioned_value = 0.0;
                //                }
                //                collisioned_value = 10000.0;
                setLatticeOutput(size, frame, row, col, dir, collisioned_value);
                dir += 1;
            }
        }
    }
}



void streamAndCollide(LatticeSize size, MaskSize mask_size, uint frame, uint row, uint col) {
    //    for (uint frame = 0; frame < size.frame_count; ++frame) {
    //        for (uint row = 0; row < size.row_count; ++row) {
    //            for (uint col = 0; col < size.col_count; ++col) {

    if (getMask(mask_size, frame, row, col)) {
        float[dir_count] dir_output = streamValue(size, mask_size, frame, row, col);

        float density = 0;
        vec3 velocity = vec3(0.0f, 0.0f, 0.0f);
        uint dir = 0;
        for (int k = -1; k <= 1; ++k) {
            for (int i = -1; i <= 1; ++i) {
                for (int j = -1; j <= 1; ++j) {
                    if (k != 0 && i != 0 && j != 0) {
                        continue;
                    }
                    float value = dir_output[dir];
                    density += value;
                    velocity += vec3(
                    value *
                    float(j),
                    value *
                    float(i),
                    value *
                    float(k));
                    dir += 1;
                }
            }
        }
        if (density > 0) {
            velocity *= lattice_speed / density;
        } else {
            density = 0.0;
            velocity = vec3(0.0f, 0.0f, 0.0f);
        }
        setVelocityDensityOutput(size, frame, row, col, velocity, density);
        altBGKEquilibrium(size, frame, row, col, density, velocity, dir_output);
    }
}

void main() {
    // terminate incase our thread size is larger than the size of grid.
    if (gl_GlobalInvocationID.z >= lattice_dimensions.frame_count
    || gl_GlobalInvocationID.y >= lattice_dimensions.row_count || gl_GlobalInvocationID.y >= lattice_dimensions.col_count){
        return;
    }
    LatticeSize lattice_size = LatticeSize(lattice_dimensions.frame_count, lattice_dimensions.row_count, lattice_dimensions.col_count, dir_count);
    MaskSize mask_size = createMaskSize(lattice_size);
    streamAndCollide(lattice_size, mask_size, gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z);
}
